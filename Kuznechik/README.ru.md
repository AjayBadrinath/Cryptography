# Кузнечик (ГОСТ Кузнечик - 128) 
[![en](https://img.shields.io/badge/lang-en-red.svg)](https://github.com/AjayBadrinath/Cryptography/blob/main/Kuznechik/README.md)
[![ru](https://img.shields.io/badge/lang-ru-blue.svg)](https://github.com/AjayBadrinath/Cryptography/blob/main/Kuznechik/README.ru.md)

## История 

Это сеть SP (подстановочная перестановка)  Шифрование на основе 128-битных блоков в соответствии со спецификациями, определенными стандартами Российского союза (ГОСТ).
Это предназначено в качестве альтернативы одобренному АНБ шифру AES (Rijndael). Кузнечик, по-видимому, был назван в честь трех авторов алгоритма (Кузьмин, Нечаев и компания)(Ru:Кузьмин, Нечаев и Компания). Однако стандарт ГОСТ для того же самого не объявляет <a href="https://github.com/AjayBadrinath/Cryptography/tree/main/GOST (MAGMA)">gost (МАГМА) шифр ( ГОСТ МАГМА Шифр )</a> несуществующим.
Недавно <a href="https://www.veracrypt.fr/code/VeraCrypt/"> VeraCrypt </a> также приняла шифр Кузнечика для шифрования диска.

## Структура 

Это блочный шифр с симметричным ключом с профилем:


      Сеть: SPN + Fiestel (для развертывания ключа)
      Размер блока: 128 бит  
      Размер ключа: 256 бит
      Размер подраздела: 128 бит
      Нет подразделов: 10 подключей
      Количество раундов: 10 Раундов
      P-Box : 16x16 -> 256
      P-Inv_Box : 16x16 -> 256
    
## Подробности 

### 1.Входные данные 

    Ключ : 256 бит 
    Сообщение (шестнадцатеричное) : n бит (будет разделено на 128-битные блоки)


### Мои комментарии
Ключ должен быть сгенерирован с использованием генератора псевдослучайных битов (256 бит). Пожалуйста, обратитесь к <a href="https://github.com/AjayBadrinath/Cryptography/tree/main/PRNG/Mersenne%20Twister">MersenneTwister</a> <a href="https://github.com/AjayBadrinath/Cryptography/tree/main/PRNG/BBS">BlumBlumShub</a> PRNG в моем репозитории. 
<br></br>
Попробуйте настроить скрипт на генерацию 256 псевдослучайных битов. Это будет ваш ключ. Я оставлю это на ваше усмотрение.
Также Кузнечик использует полевую арифметику Галуа <код> (Операции над полем GF(2)[x]->p(x) ) с p(x)=x<sup>8</sup>+x<sup>7</sup>+x<sup>6</sup>+x+1 </code>Таким образом, для понимания исходного кода потребуются некоторые знания по арифметике поля Галуа и теории чисел.

### 2.P-BOX
Нелинейное биективное преобразование P-Box определено в стандартах как P = V<sub>8</sub> &#960;<sup>-1</sup>Int<sub>8</sub>
Где V<sub>8</sub> - биективное отображение, связанное с кольцом Z<sub>2<sup>8</sup></sub>=>V<sub>8</sub>- Z<sub>2<sup>8</sup></sub> и 

Int<sub>8</sub> относится к обратному отображению вектору V<sup>-1</sup>, то есть V<sub>8</sub>=> Z<sub>2<sup>8</sup></sub>- V<sub>8</sub>


## Преобразования {Шифрование}

Шифр Кузнечика использует множество преобразований для выполнения подстановки и перестановочности в каждом блоке

### 1.S-преобразование

<hr>

Здесь мы называем S-преобразование подстановкой из p-блока
Это преобразование формально определено в 128-битном отображении векторного пространства 


<code>V<sub>128</sub>->V<sub>128</sub> : S(x):S(x<sub>15</sub>||...||x<sub>0</sub>)= &#960;(x<sub>15</sub>)||...|| &#960;( x<sub>0</sub>)</code>


|| Относится к операции объединения.

Реализация:

Поддерживайте переменную s таким образом, чтобы s сдвигалось влево на 8 бит при каждой итерации (16) таким образом, чтобы (16*8= 128) бит замещенных битов из блока P получались 
0xff действует как 8-битная маска.


```python
s=0
for i in range(15,-1,-1):
  s<<=8
  s^=(self.pi[(x>>8*i&0xff)])

return s
```



<hr>

### 2.Преобразование R 

Преобразование R, определенное в стандартах отображения 128-битного векторного пространства :

<code>V<sub>128</sub>->V<sub>128</sub> : R(x):R(x<sub>15</sub>||...||x<sub>0</sub>)=L(x<sub>15</sub>||...||x<sub>0</sub>)||x<sub>15</sub>||...||x<sub>1</sub></code>


Где <code> L(k) k=x<sub>15</sub>||...||x<sub>0</sub></code> относится к функции линейного преобразования .

Реализация : 
Примените линейное преобразование ко всему входному xor со всеми остальными x, кроме x<sub>0</sub> (8 бит LSB)
```python
((linear_Transformation(x)<<120)^(x>>8))
```


### 3.L-преобразование

L-преобразование, определенное в стандартах отображения 128-битного векторного пространства :
<code>V<sub>128</sub>->V<sub>128</sub> : R<sup>16</sup>(x)</code> 
Что означает повторное применение R(x) к x 16 раз
Реализация:
(Применить R(x) к X )* 16
```python
for _ in range(16):
  x=self.R_Transformation(x)

```
<hr>

### 4. Линейное преобразование:
Линейное преобразование определяется из отображения векторного пространства:
<code>V<sup>16</sup><sub>8</sub>->V<sub>8</sub></code>:
<code>_iter=[148,32,133,16,194,192,1,251,1,192,194,16,133,32,148,1]</code>
    Определяем l(x): &#x2207;(_iter[0]*&#x0394;(x<sub>15</sub>)||...||_iter[-1]*&#x0394;(x<sub>0</sub>)) Операции сложения и умножения закрыты в поле.
    Реализация:
    
    
```python
    
    _map_=[148,32,133,16,194,192,1,251,1,192,194,16,133,32,148,1][::-1]
    res=0

    for i in range(15,-1,-1):
         res^=self.Mod_Polynomial_Reduction(self.M(_map_[i],(x>>8*i)&0xff),0b111000011)

 ```
## Преобразования {Расшифровка}



### 1.S-обратное преобразование

<hr>

При этом мы ссылаемся на S<sup>-1</sup>-преобразование как на замену из p-box
Это преобразование формально определено в 128-битном отображении векторного пространства 


<code>V<sub>128</sub>->V<sub>128</sub> : S<sup>-1</sup>(x):S<sup>-1</sup>(x<sub>15</sub>||...||x<sub>0</sub>)= &#960;<sup>-1</sup>(x<sub>15</sub>)||...|| &#960;< sup>-1</sup>(x<sub>0</sub>)</code>


|| Относится к операции объединения.

Реализация:

Поддерживайте переменную s таким образом, чтобы s сдвигалось влево на 8 бит при каждой итерации (16), так что (16*8= 128) бит замещенных битов из поля P<sup>-1</sup> получается 
0xff действует как 8-битная маска.


```python
s=0
for i in range(15,-1,-1):
      s<<=8
      s^=(self.pi_inv[(x>>8*i&0xff)])
            

```



### 2.Обратное преобразование R 

Преобразование R<sup>-1</sup>, определенное в стандартах отображения 128-битного векторного пространства :

<code>V<sub>128</sub>->V<sub>128</sub> : R<sup>-1</sup> (x):R<sup>-1</sup> (x<sub>15</sub>||...||x<sub>0</sub>)=x<sub>14</sub>||...||x<sub>0</sub>||L(x<sub>15</sub>||...||x<sub>0</sub>)</code>


Где <code> L(k) k=x<sub>15</sub>||...||x<sub>0</sub></code> относится к функции линейного преобразования .

Реализация : 
Примените линейное преобразование ко всему входному xor со всеми остальными x, кроме x<sub>15</sub> (8 бит MSB)
```python
((x<<8)^self.linear_Transformation(x<<8^((x>>120)&0xff)))
```
### 3.L Обратное преобразование

Преобразование L<sup>-1</sup>, определенное в стандартах отображения 128-битного векторного пространства :
<code>V<sub>128</sub>->V<sub>128</sub> : (R<sup>-1</sup>)<sup>16</sup>(x)</code> 
Значение многократного применения R(x) к x 16 раз
Реализация:
(Примените R<sup>-1</sup>(x) к X)* 16
```python
for _ in range(16):
      x=self.R_Transformation_inverse(x)

```
## Разные функции {Дешифрование} {Шифрование}
Это функции, которые используются для выполнения умножения и модуляции в поле Галуа F, рассмотренном выше для многочлена p(x)
Чтобы понять суть того, что здесь делается, пожалуйста, обратитесь к ссылкам, указанным в источнике.
### 1.Функция M 
Эта функция, по сути, умножает два двоичных многочлена и возвращает их произведение
Алгоритм:
      Выполнение умножения в поле{0,1} по сути является сдвигом битов влево. 
      1.So Сохраняйте множимое значение постоянным
      2.Нам нужно просто поработать с множителем, и вот он <code>y</code>. 
      3.Получите доступ к каждому LSB из y, используя <code>y&1</code>, и проверьте, равен ли LSB 1 . Это означает, что в двоичном многочлене есть степень {0,1}y=>1.y<sup>град</sup>
      4.Сохраните другую переменную в качестве результата xor с помощью <code>x<<deg</code> , deg здесь - степень многочлена (битовый индекс) от y , где коэффициент =1
5. увеличивайте deg до тех пор, пока мы не исчерпаем множитель y (<code>y>>1</code>)
      

```python
c=0
deg=0
while y!=0:
      if(y&1):
            c^=(x<<deg)
      deg+=1
      y>>=1
```

### 2.Deg Poly 
Эта функция выполняет то же самое, что и deg, определенная выше, но специфична для варианта использования, который диктует, где нам нужно найти наивысшую степень данного многочлена ofc len (str) делает то же самое.. но сдвиг битов кажется более разумным. Я имею в виду, что эта функция может динамически использоваться повторно, когда многочлен постоянно уменьшается во время итерации (зависимая переменная), (<code>k>>=1 или k<<=1</code>).Таким образом, степени действительно меняются.

```python
deg=0
while x!=0:
      deg+=1
      x>>=1
```


### 3. Модальное полиномиальное сокращение 
Эта функция предназначена для вычисления модуля в GF .Это делается для уменьшения произведения функции M в область GF (p<x>). Здесь эта функция не является специфичной для конкретной области как таковой. Но Кузнечик использует <code> GF(2)[x]->p(x)=x<sup>8</sup>+x<sup>7</sup>+x<sup>6</sup>+x+1 (111000011) в качестве mod</code> как его модульная область.
Таким образом, любой продукт, полученный из функции M, необходимо свести к области GF(2)[x]->p(x).

Алгоритм:
            1.Повторяйте до тех пор, пока deg(z) <deg(mod): при выполнении (m<<diff), где diff - это 
            разница между наивысшей степенью z и самим m

```python
z=x
while True:
      if(self.degree_Poly(z)<self.degree_Poly(m)):
            break
      else:
            diff=self.degree_Poly(z)-self.degree_Poly(m)
            z^=(m<<diff)
```
## Функции развертывания ключей {Дешифрование} {Шифрование} KDF
Интересно, что, как я обсуждал выше, этот алгоритм уникален в том смысле, что он использует структуру Fiestel для своей функции развертывания ключей.
Кузнечик использует 256-битный начальный ключ и 128-битные ключи секционирования для каждого раунда (10)

### 1.Преобразование F
Это та часть, которая выполняет замену Fiestel, где мы, по сути, применяем (L(S(roundconst^k1))^k2,k1), где + в соответствии с GF {0,1} неявно подразумевает операцию xor.
Возвращает две части, где k1 остается нетронутым и возвращается, а другой ключ - (k1) xor (c), где c - круглая константа.Затем, наконец, применены слои преобразования LS в том же порядке.
```python
[self.L_Transformation(self.S_Transformation(c1^k1))^k2,k1]
```


### 2. Функция Round 
Эта функция, по сути, является просто служебной функцией для вычисления Round const (128 бит) Для i={0...9} и возвращает L_Transformation(round_no)
```python
(self.L_Transformation(round_no))
```
### 3. Ключевая функция расписания
Эта функция используется для вычисления ключевых разделов (подразделов) для каждого раунда с использованием константы раунда и преобразования F, рассмотренных выше.
Начальные ключевые разделы равны
k1=K<sub>256</sub>||...||K<sub>128</sub>
k2=K<sub>127</sub>||...||K<sub>0</sub>
Вкратце, эта функция выполняется так, как описано в стандарте ГОСТ:
<code>
(K<sub>2i+1</sub>,K<sub>2i+2</sub>)=fтрансформация(RoundConst<sub>8(i-1)+8</sub>)...Fтрансформация(RoundConst<sub>8(i-1)+1</sub>(K<sub>2i-1</sub>,K<sub>2i</sub>)
i={1,2,3,4}
</code>
```python
k1=(key>>128)&self.MASK_32
k2=(key)&self.MASK_32
key_arr=[k1,k2]
for i in range(1,33):
      c=self.Round_constant(i)
      f=self.F_Transformation(c,k1,k2)
      k1,k2=f
      if(i%8==0):
          key_arr.extend([k1,k2])
```
## Шифрование
Шифрование выполняется с использованием нескольких подключей раунда с композицией функций L Transformation(S Transformation(x+k)), повторяющихся до 9 раунда, и заключительный раунд без композиции, мы просто выполняем x+k<sub>10</sub>, представляющий последний подключевой ключ. Обратите внимание, что для шифрования мы используем функции, помеченные как {Шифрование}/{Разное.}.
```python
a=self.message
k=self.Key_Schedule(self.key)
for i in range(9):
      
      a=self.L_Transformation(self.S_Transformation(k[i]^a))

return a^k[-1]
```
### Расшифровка
Дешифрование аналогично шифрованию и выполняется с использованием нескольких дополнительных ключей раунда в обратном порядке с композицией функций S Обратное преобразование( L Обратное преобразование((x+k))) повторяется до раунда 1 (начиная с обратного), и последний раунд без композиции, мы просто выполняем x+k<sub>0</sub>, представляющий первый дополнительный ключ. Обратите внимание, что для расшифровки мы используем функции, помеченные как {Расшифровка}/{Разное.}.
```python
pt=cipher
k=self.Key_Schedule(self.key)

for i in (range(9,0,-1)):
      pt=self.S_Inv_Transformation(self.L_Transformation_inverse(k[i]^pt))
return pt^k[0]
```
### Реализация
Ознакомьтесь с <a href ="https://github.com/AjayBadrinath/Cryptography/tree/main/Utils/FileCrypt">FileCrypt</a>, где я использовал свою реализацию Кузнечик шифр для шифрования файлов. (Мне еще предстоит улучшить его производительность как таковую.).
